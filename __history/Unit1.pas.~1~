unit Unit1;

{ Convertit une chaîne en transformant les accentués en majuscule
  non accentués. Utilise l'assembleur intégré

  Modif : String ==> AnsiString
}

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls;

type
  TForm1 = class(TForm)
    Button1: TButton;
    Edit1: TEdit;
    Button2: TButton;
    procedure Button1Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure Button2Click(Sender: TObject);
  private
         { Déclarations privées }
  public
        { Déclarations publiques }
  end;

const
  loop = 10000000;
var
  Form1: TForm1;
  strTempo : ansistring;
  somevar: byte;
  start, stop : longint;

implementation

{$R *.DFM}

procedure Convert (str2Convert : Ansistring);
var
   nLenStr : word;
begin
     nLenStr := length(str2Convert);
     asm
     push ebx   { sauve ebx et edi (pour Delphi) }
     push edi
     jmp @debut { au travail ! }
@table :
     {DB 'éEèEêEëEàAâAäAçCîIïIôOöOùUûUüUÿY', 0,0 ancienne table}
     DB 'ÅAåAàAâAäAÄAÂAéEèEêEëEËEÊEíIìIîIïIÏIÎIóOôOöOÖOÔOõOÕOúUùUûUüUÜUÛUýYÿYçCñNÑNŠSšS',0,0
     {DB 'éE',0,0}
@debut :
     //xor eax,eax
     mov ax, nLenStr
     //shl eax,1
     or ax,ax              { mise à jour du flag Z }
     jz @fin               { longueur nulle -> fin }
@loop_principale:          { sur les car. de la chaîne à traiter }
     mov edi, OFFSET @table  { adr. de la table de corres. dans edi}
     mov ecx, str2Convert  { adr. de la chaîne à conv. ds ecx }
     add cx, nLenStr       { on commence par la fin }
     dec ecx               { ajustement }
     mov al, byte [ecx]    { caractère de la chaîne ds AL }
@loop_compar:
     cmp al, byte [edi]    { Comparaison }
     jnz @car_accentue_suivant { c'est pas ça, suite de la table }
     mov bl, byte [edi + 1]{ bingo! : corection }
     mov byte [ecx], bl   { Correction }
     jmp @testfin         { fin de chaîne atteinte ? }
@car_accentue_suivant:    { on passe à l'entrée suivant de la table }
     inc edi
     inc edi              { 2 octets plus loin }
     mov bl, byte [edi]   { récupère entrée suiv. de la table }
     or bl,bl             { mise à jour du flag Z }
     jnz  @loop_compar    { on est en fin de table ?}
     mov edi, OFFSET @table   { oui : retour en début de table }

@testfin:
     dec nLenStr   { car. précédent }
     push ax
     mov ax, nLenStr
     mov somevar, al
     pop ax
     jnz @loop_principale { on n'a pas fini ! }
@fin:
     pop edi
     pop ebx              { rétablissement de ebx/edi pour Delphi }
     end ;                { job's done ! }

end;

procedure TForm1.Button1Click(Sender: TObject);
var
   code : integer;
   savstrTempo : ansistring;
   i,k : longint;

begin
     strTempo := AnsiString(Edit1.Text);
     start := gettickCount;
     for k := 1 to loop do Convert(strTempo);
     stop := gettickCount;
     strTempo := UpperCase(strTempo) + ' temps = ' + IntToStr(stop-start);
     Edit1.Text := strTempo;
end;

procedure TForm1.Button2Click(Sender: TObject);
var
  i,j,k : integer;
  s : string;
  ss : string;
  match : boolean;
begin
  s := 'ÅAåAàAâAäAÄAÂAéEèEêEëEËEÊEíIìIîIïIÏIÎIóOôOöOÖOÔOõOÕOúUùUûUüUÜUÛUýYÿYçCñNÑNŠSšS';
  ss := Edit1.Text;
  start := gettickCount;
  for k := 1 to loop do
  begin
    for i := 1 to length(ss) do
    begin
      j := 1;
      repeat
          if ss[i] = s[j] then ss[i] := s[j+1];
          j := j +2;
      until (match) or (j>= length(s));
    end;
  end;
  stop := gettickCount;
  strTempo := UpperCase(ss) + ' temps = ' + IntToStr(stop-start);
  Edit1.Text := strTempo;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
     Edit1.Text := 'ééé';
end;

end.
